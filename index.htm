<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Document</title>
  </head>
  <style>
    html,
    body {
      height: 100%;
      margin: 0;
      padding: 0px;
      overflow: hidden;
    }

    #canvas {
      width: 100%;
      height: 100%;
      background: #111;
    }
  </style>
  <body>
    <!-- This is a very basic canvas example which allows for panning and zooming using a mouse (Click & drag & scrollwheel)  -->
    <!-- Panning lets you move a view to another location without changing its magnification.  -->
    <!-- Zooming lets you view the drawing with more or less magnification. -->
    <!-- https://codepen.io/chengarda/pen/wRxoyB -->
    <canvas id="canvas"></canvas>
  </body>
  <script>
    let canvas = document.getElementById('canvas');
    let ctx = canvas.getContext('2d');

    let cameraOffset = { x: window.innerWidth / 2, y: window.innerHeight / 2 };
    let cameraZoom = 1;
    let MAX_ZOOM = 5;
    let MIN_ZOOM = 0.1;
    let SCROLL_SENSITIVITY = 0.0005;

    // Функция draw отвечает за непрерывное обновление содержимого элемента canvas.
    function draw() {
      // установка ширины и высоты элемента canvas в соответствии с шириной и высотой окна браузера.
      // Это гарантирует, что canvas заполняет все окно просмотра и изменяет размер при изменении размера окна.
      canvas.width = window.innerWidth;
      canvas.height = window.innerHeight;

      // Эта строка устанавливает центр масштабирования / контекст рисования (ctx) в центр canvas.
      // Это важно, потому что следующая операция scale будет увеличивать/уменьшать масштаб относительно этой центральной точки.
      ctx.translate(window.innerWidth / 2, window.innerHeight / 2);

      // Эта строка применяет текущий уровень масштабирования (cameraZoom) к контексту рисования.
      // Значение больше 1 увеличивает масштаб, значение меньше 1 уменьшает масштаб.
      ctx.scale(cameraZoom, cameraZoom);

      //Эта строка снова устанавливает центр масштабирования / контекст рисования (ctx), но на этот раз на величину,
      // определяемую переменной cameraOffset.
      //Это смещение фактически перемещает окно просмотра в пределах увеличенной области canvas.
      ctx.translate(
        -window.innerWidth / 2 + cameraOffset.x,
        -window.innerHeight / 2 + cameraOffset.y
      );

      // Очистка холста. Эта строка очищает всю область canvas, прежде чем рисовать что-либо новое.
      // Это гарантирует, что не осталось никаких остатков от предыдущих кадров.
      ctx.clearRect(0, 0, window.innerWidth, window.innerHeight);

      // Эта строка устанавливает стиль заливки для фигур, нарисованных на canvas, в темно-красный цвет (#991111).
      ctx.fillStyle = '#991111';

      // Эта строка рисует прямоугольник на canvas.
      // Прямоугольник имеет положение (-150, -50) относительно текущего контекста рисования, ширину 200 пикселей и высоту 100 пикселей.
      ctx.fillRect(-150, -50, 200, 100);

      // Эта строка устанавливает стиль заливки для текста, нарисованного на canvas, в белый (#fff).
      ctx.fillStyle = '#fff';

      // Эта строка устанавливает размер шрифта и шрифт "georgia"
      // Рисует текст "Simple" на canvas. Текст расположен в (-100, 0) относительно текущего контекста рисования.
      ctx.font = `32px georgia`;
      ctx.fillText('Simple', -100, 0);

      // Эта строка вызывает функцию requestAnimationFrame из Animation API браузера.
      // Эта функция планирует вызов функции draw снова, как только браузер будет готов перерисовать canvas.
      // Это создает непрерывный цикл анимации, фактически перерисовывая сцену всякий раз, когда это необходимо.

      // Вкратце, функция draw постоянно повторно отображает содержимое на canvas, основываясь на текущем уровне масштабирования,
      // смещении камеры и определенных фигурах и тексте.
      // Использование requestAnimationFrame обеспечивает плавную анимацию и избегает ненужных перерисовок.
      requestAnimationFrame(draw);
    }

    // Gets the relevant location from a mouse
    function getEventLocation(e) {
      if (e.clientX && e.clientY) {
        return { x: e.clientX, y: e.clientY };
      }
    }

    let isDragging = false;
    let dragStart = { x: 0, y: 0 };

    function onPointerDown(e) {
      isDragging = true;
      dragStart.x = getEventLocation(e).x / cameraZoom - cameraOffset.x;
      dragStart.y = getEventLocation(e).y / cameraZoom - cameraOffset.y;
    }

    function onPointerUp(e) {
      isDragging = false;
      initialPinchDistance = null;
      lastZoom = cameraZoom;
    }

    function onPointerMove(e) {
      if (isDragging) {
        cameraOffset.x = getEventLocation(e).x / cameraZoom - dragStart.x;
        cameraOffset.y = getEventLocation(e).y / cameraZoom - dragStart.y;
      }
    }

    let initialPinchDistance = null;
    let lastZoom = cameraZoom;

    function adjustZoom(zoomAmount, zoomFactor) {
      if (!isDragging) {
        if (zoomAmount) {
          cameraZoom += zoomAmount;
        } else if (zoomFactor) {
          console.log(zoomFactor);
          cameraZoom = zoomFactor * lastZoom;
        }

        cameraZoom = Math.min(cameraZoom, MAX_ZOOM);
        cameraZoom = Math.max(cameraZoom, MIN_ZOOM);

        console.log(zoomAmount);
      }
    }

    canvas.addEventListener('mousedown', onPointerDown);
    canvas.addEventListener('mouseup', onPointerUp);
    canvas.addEventListener('mousemove', onPointerMove);
    canvas.addEventListener('wheel', e =>
      adjustZoom(e.deltaY * SCROLL_SENSITIVITY)
    );

    draw();
  </script>
</html>
